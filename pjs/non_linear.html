<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Descent: Non-Linear Regression (Quadratic Model)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .container {
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            max-width: 900px;
            padding: 40px;
            box-sizing: border-box;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.8em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            color: #666;
        }

        .step {
            background-color: #ffffff;
            border: 1px solid #e6e6e6;
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        }

        .step-number {
            position: absolute;
            top: -15px;
            left: 20px;
            background-color: #4ecdc4;
            color: #fff;
            font-size: 1.6em;
            font-weight: bold;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 10px rgba(78, 205, 196, 0.4);
        }

        .step h2 {
            color: #34495e;
            font-size: 2em;
            margin-top: 0;
            margin-bottom: 25px;
            padding-left: 60px; /* Space for step number */
        }

        .step h3 {
            color: #2c3e50;
            font-size: 1.5em;
            margin-top: 25px;
            margin-bottom: 15px;
        }

        .formula {
            background-color: #ecf0f1;
            padding: 18px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 1.3em;
            text-align: center;
            margin: 25px 0;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);
            color: #2c3e50;
        }

        .math-section {
            background-color: #f8fcfb;
            border-left: 4px solid #4ecdc4;
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
        }

        .math-section h4 {
            color: #34495e;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            font-size: 0.95em;
            background-color: #fafafa;
        }

        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        .data-table th {
            background-color: #4ecdc4;
            color: white;
            font-weight: bold;
        }

        .data-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        .data-table tr:hover {
            background-color: #e0f2f1;
        }

        .chart-container {
            background-color: #fcfcfc;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin: 30px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.03);
        }

        canvas {
            background-color: #fff;
            border-radius: 6px;
        }

        .interactive-controls {
            background-color: #f7f7f7;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 25px;
            margin: 30px 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        }

        .interactive-controls h4 {
            text-align: center;
            color: #34495e;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: bold;
            color: #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-group input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            background: #ddd;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4ecdc4;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(78, 205, 196, 0.5);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4ecdc4;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(78, 205, 196, 0.5);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .metric-card {
            background-color: #f0f8f7;
            border: 1px solid #d4eeed;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .metric-card h4 {
            color: #34495e;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .metric-card .value {
            font-size: 1.8em;
            font-weight: bold;
            color: #e74c3c; /* A distinct color for values */
        }
        
        .explanation-box {
            background-color: #fefceb;
            border-left: 4px solid #f9d423;
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
        }

        .explanation-box h4 {
            color: #d1b100;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .gradient-visualization {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 30px 0;
            gap: 20px;
            font-size: 1.1em;
            color: #555;
        }

        .gradient-arrow {
            font-size: 2.5em;
            color: #888;
        }

        .calculation-box {
            background-color: #f4f7f6;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            margin: 25px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 1em;
        }

        .calculation-box h4 {
            color: #34495e;
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        }

        .calculation-step {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px 0;
            border-bottom: 1px dashed #eee;
        }

        .calculation-step:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .algorithm-box {
            background-color: #ebf5ff;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
        }

        .algorithm-box h4 {
            color: #2980b9;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .algorithm-step {
            margin-bottom: 10px;
            padding-left: 15px;
            position: relative;
        }

        .algorithm-step::before {
            content: "‚Ä¢";
            color: #3498db;
            position: absolute;
            left: 0;
        }

        button {
            background-color: #4ecdc4;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            margin: 5px;
            box-shadow: 0 4px 10px rgba(78, 205, 196, 0.4);
        }

        button:hover {
            background-color: #3bb2aa;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        .iteration-demo {
            background-color: #ecf8f7;
            border: 1px solid #d4eeed;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            text-align: center;
        }

        .iteration-header {
            font-size: 1.5em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .iteration-details {
            text-align: left;
            margin-top: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .final-solution {
            text-align: center;
            background-color: #e6ffee;
            border: 2px solid #2ecc71;
            border-radius: 12px;
            padding: 35px;
            margin-top: 50px;
            box-shadow: 0 8px 25px rgba(46, 204, 113, 0.2);
        }

        .final-solution h3 {
            color: #27ae60;
            font-size: 2.5em;
            margin-top: 0;
        }

        .final-solution p {
            font-size: 1.2em;
            color: #333;
        }

        .final-solution .formula {
            background: #d0f0d0;
            border: 1px dashed #2ecc71;
            padding: 25px;
            font-size: 1.5em;
            font-weight: bold;
            color: #27ae60;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Gradient Descent for Non-Linear Regression</h1>
            <p>Complete Step-by-Step Guide with a Quadratic Model</p>
            <p><em>Average Production Cost Example</em></p>
        </div>

        <div class="step">
            <div class="step-number">1</div>
            <h2>üìà Problem Setup & Data: Average Production Cost</h2>
            <p>We want to model the average cost of production based on the quantity produced. This relationship is often non-linear, typically forming a U-shape. Our model equation will be a quadratic function:</p>
            
            <div class="formula">
                ≈∑ = ax¬≤ + bx + c
            </div>
            
            <p>Where:</p>
            <ul style="margin: 15px 0; padding-left: 30px;">
                <li><strong>≈∑</strong> = predicted Average Cost</li>
                <li><strong>a</strong>, <strong>b</strong>, <strong>c</strong> = parameters (weights/bias) to be learned</li>
                <li><strong>x</strong> = Quantity Produced</li>
            </ul>
            
            <h3>üìä Training Dataset</h3>
            <p>Here's a sample dataset showing how average cost changes with quantity:</p>
            <table class="data-table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Quantity (x)</th>
                        <th>Average Cost (y)</th>
                    </tr>
                </thead>
                <tbody id="dataTableBody">
                    <tr><td>1</td><td>10</td><td>25.0</td></tr>
                    <tr><td>2</td><td>20</td><td>18.0</td></tr>
                    <tr><td>3</td><td>30</td><td>13.0</td></tr>
                    <tr><td>4</td><td>40</td><td>10.0</td></tr>
                    <tr><td>5</td><td>50</td><td>9.0</td></tr>
                    <tr><td>6</td><td>60</td><td>9.5</td></tr>
                    <tr><td>7</td><td>70</td><td>11.0</td></tr>
                    <tr><td>8</td><td>80</td><td>14.0</td></tr>
                    <tr><td>9</td><td>90</td><td>18.0</td></tr>
                    <tr><td>10</td><td>100</td><td>23.0</td></tr>
                </tbody>
            </table>
            
            <div class="chart-container">
                <canvas id="dataCanvas" width="600" height="300"></canvas>
            </div>
            <div class="explanation-box">
                <h4>‚ö†Ô∏è Importance of Data Scaling (Normalization)</h4>
                <p>For polynomial regression, especially with terms like $x^2$, the values can become very large (e.g., if x is 100, $x^2$ is 10,000). This can cause numerical instability and make gradient descent difficult to converge. To address this, we internally scale (normalize) our data (both x and y) to a smaller range (e.g., 0 to 1) before training, and then de-scale for plotting and final results.</p>
            </div>
        </div>

        <div class="step">
            <div class="step-number">2</div>
            <h2>üìè Cost Function (Mean Squared Error)</h2>
            
            <p>Just like linear regression, we use the Mean Squared Error (MSE) to quantify the difference between our predictions and the actual values:</p>
            
            <div class="formula">
                J(a,b,c) = (1/2n) √ó Œ£(y·µ¢ - ≈∑·µ¢)¬≤
            </div>
            
            <div class="math-section">
                <h4>üîç Breaking Down the Cost Function</h4>
                <p><strong>Step 1:</strong> Calculate prediction for each data point: ≈∑·µ¢ = a √ó x·µ¢¬≤ + b √ó x·µ¢ + c</p>
                <p><strong>Step 2:</strong> Find the error: (y·µ¢ - ≈∑·µ¢)</p>
                <p><strong>Step 3:</strong> Square the error: (y·µ¢ - ≈∑·µ¢)¬≤</p>
                <p><strong>Step 4:</strong> Sum all squared errors and average: (1/2n) √ó Œ£(y·µ¢ - ≈∑·µ¢)¬≤</p>
                <p><em>Note: The 1/2 factor simplifies the derivative calculation.</em></p>
            </div>
        </div>

        <div class="step">
            <div class="step-number">3</div>
            <h2>‚àá Partial Derivatives (Gradients)</h2>
            
            <p>To minimize the cost function J(a,b,c), we need to find the partial derivatives with respect to each parameter (a, b, and c). These derivatives tell us the "slope" of the cost function with respect to each parameter.</p>
            
            <div class="math-section">
                <h4>üìê Derivative with respect to 'a':</h4>
                <div class="formula">
                    ‚àÇJ/‚àÇa = (1/n) √ó Œ£(≈∑·µ¢ - y·µ¢) √ó x·µ¢¬≤
                </div>
                
                <h4>üìê Derivative with respect to 'b':</h4>
                <div class="formula">
                    ‚àÇJ/‚àÇb = (1/n) √ó Œ£(≈∑·µ¢ - y·µ¢) √ó x·µ¢
                </div>

                <h4>üìê Derivative with respect to 'c':</h4>
                <div class="formula">
                    ‚àÇJ/‚àÇc = (1/n) √ó Œ£(≈∑·µ¢ - y·µ¢)
                </div>
            </div>
            
            <div class="explanation-box">
                <h4>üß† Intuitive Understanding</h4>
                <p>The gradient indicates the direction of the steepest ascent of the cost function. To minimize the cost, Gradient Descent moves in the *opposite* direction of the gradient. A positive gradient means increasing the parameter will increase cost, so we decrease the parameter, and vice-versa.</p>
            </div>
        </div>

        <div class="step">
            <div class="step-number">4</div>
            <h2>üìù Manual Calculation Example (One Iteration)</h2>
            
            <p>Let's walk through one iteration using **scaled data** and initial parameters (A=0, B=0, C=0) to understand how gradients are computed. For this example, we'll pick the first data point:</p>
            <ul>
                <li>Original data point 1: x = 10, y = 25.0</li>
                <li>After Min-Max Scaling (approx): x_scaled ‚âà 0, y_scaled ‚âà 1</li>
            </ul>
            <p><em>Note: Actual scaled values are slightly different for precise calculation due to actual min/max, but the principle is the same. We use (A, B, C) for scaled parameters.</em></p>
            
            <div class="calculation-box">
                <h4>Initial Parameters (Scaled): A = 0, B = 0, C = 0</h4>
                <h4>Example for Data Point 1 (x_scaled ‚âà 0.0, y_scaled ‚âà 1.0)</h4>
                <div class="calculation-step">
                    <span>≈∑‚ÇÅ (scaled) = A √ó x‚ÇÅ¬≤ + B √ó x‚ÇÅ + C</span>
                    <span>= 0 √ó (0)¬≤ + 0 √ó (0) + 0 = 0</span>
                </div>
                <div class="calculation-step">
                    <span>Error (scaled) = ≈∑‚ÇÅ - y‚ÇÅ = 0 - 1.0</span>
                    <span>= -1.0</span>
                </div>
            </div>

            <div class="calculation-box">
                <h4>Calculating Gradients (Simplified for single point for illustration)</h4>
                <div class="calculation-step">
                    <span>‚àÇJ/‚àÇA ‚âà (1/1) √ó (0 - 1.0) √ó (0)¬≤</span>
                    <span>= 0</span>
                </div>
                <div class="calculation-step">
                    <span>‚àÇJ/‚àÇB ‚âà (1/1) √ó (0 - 1.0) √ó (0)</span>
                    <span>= 0</span>
                </div>
                <div class="calculation-step">
                    <span>‚àÇJ/‚àÇC ‚âà (1/1) √ó (0 - 1.0)</span>
                    <span>= -1.0</span>
                </div>
                <p style="text-align:center; font-style: italic; margin-top:15px;">
                    (In real calculation, we sum for all 'n' data points before dividing by 'n')
                </p>
            </div>
        </div>

        <div class="step">
            <div class="step-number">5</div>
            <h2>üöÄ Learning Rate & Parameter Updates</h2>
            
            <div class="algorithm-box">
                <h4>üîÑ Gradient Descent Algorithm for Quadratic Regression</h4>
                <div class="algorithm-step">
                    <strong>Step 1:</strong> Initialize parameters a, b, and c randomly (or to 0).
                </div>
                <div class="algorithm-step">
                    <strong>Step 2:</strong> For each iteration, calculate predictions (≈∑·µ¢) and the cost J(a,b,c) using the current a, b, c values.
                </div>
                <div class="algorithm-step">
                    <strong>Step 3:</strong> Calculate the partial derivatives (gradients) ‚àÇJ/‚àÇa, ‚àÇJ/‚àÇb, and ‚àÇJ/‚àÇc.
                </div>
                <div class="algorithm-step">
                    <strong>Step 4:</strong> Update parameters using the learning rate (Œ±):
                        <div class="formula" style="margin: 10px 0; font-size: 1.1em; padding: 10px;">
                            a<sub>new</sub> = a<sub>old</sub> - Œ± √ó ‚àÇJ/‚àÇa<br>
                            b<sub>new</sub> = b<sub>old</sub> - Œ± √ó ‚àÇJ/‚àÇb<br>
                            c<sub>new</sub> = c<sub>old</sub> - Œ± √ó ‚àÇJ/‚àÇc
                        </div>
                </div>
                <div class="algorithm-step">
                    <strong>Step 5:</strong> Repeat steps 2-4 until convergence (cost change is minimal or max iterations reached).
                </div>
            </div>
            
            <div class="explanation-box">
                <h4>üéõÔ∏è Learning Rate (Œ±) Effects</h4>
                <p>The learning rate determines the size of the step taken down the cost function's gradient.
                <br><strong>Too Small:</strong> Very slow convergence.
                <br><strong>Too Large:</strong> May overshoot the minimum, oscillate, or even diverge.</p>
            </div>
        </div>

        <div class="step">
            <div class="step-number">6</div>
            <h2>üéÆ Interactive Training Simulation</h2>
            
            <div class="interactive-controls">
                <h4>üèÉ‚Äç‚ôÇÔ∏è Watch Quadratic Regression Learn!</h4>
                
                <div class="controls-grid">
                    <div class="control-group">
                        <label>Learning Rate (Œ±): <span id="learningRateValue">0.5</span></label>
                        <input type="range" id="learningRateSlider" min="0.01" max="1.0" step="0.01" value="0.5" oninput="document.getElementById('learningRateValue').textContent = parseFloat(this.value).toFixed(2)">
                    </div>
                    <div class="control-group">
                        <label>Initial 'a' (Scaled): <span id="initAScaledValue">0.0</span></label>
                        <input type="range" id="initAScaledSlider" min="-1" max="1" step="0.01" value="0" oninput="document.getElementById('initAScaledValue').textContent = parseFloat(this.value).toFixed(2); resetTraining()">
                    </div>
                    <div class="control-group">
                        <label>Initial 'b' (Scaled): <span id="initBScaledValue">0.0</span></label>
                        <input type="range" id="initBScaledSlider" min="-1" max="1" step="0.01" value="0" oninput="document.getElementById('initBScaledValue').textContent = parseFloat(this.value).toFixed(2); resetTraining()">
                    </div>
                     <div class="control-group">
                        <label>Initial 'c' (Scaled): <span id="initCScaledValue">0.0</span></label>
                        <input type="range" id="initCScaledSlider" min="-1" max="1" step="0.01" value="0" oninput="document.getElementById('initCScaledValue').textContent = parseFloat(this.value).toFixed(2); resetTraining()">
                    </div>
                    <div class="control-group">
                        <label>Max Iterations: <span id="maxIterationsValue">10000</span></label>
                        <input type="range" id="maxIterationsSlider" min="100" max="20000" step="100" value="10000" oninput="document.getElementById('maxIterationsValue').textContent = this.value">
                    </div>
                    <div class="control-group">
                        <label>Convergence Threshold: <span id="convergenceThresholdValue">0.0000001</span></label>
                        <input type="range" id="convergenceThresholdSlider" min="0.00000001" max="0.0001" step="0.00000001" value="0.0000001" oninput="document.getElementById('convergenceThresholdValue').textContent = parseFloat(this.value).toFixed(8)">
                    </div>
                </div>
                
                <div style="text-align: center; margin: 20px 0;">
                    <button id="startBtn" onclick="startTraining()">üöÄ Start Training</button>
                    <button id="stopBtn" onclick="stopTraining()" disabled>‚è∏Ô∏è Stop Training</button>
                    <button id="stepBtn" onclick="singleStep()">‚û°Ô∏è Single Step</button>
                    <button id="resetBtn" onclick="resetTraining()">üîÑ Reset</button>
                </div>
            </div>

            <div class="iteration-demo" id="iterationInfo" style="display: none;">
                <div class="iteration-header">Iteration <span id="iterationNumber">1</span></div>
                <div class="calculation-box">
                    <div id="iterationDetails"></div>
                </div>
            </div>
            
            <div class="chart-container">
                <canvas id="trainingCanvas" width="600" height="300"></canvas>
            </div>
            
            <div class="metrics-grid">
                <div class="metric-card">
                    <h4>Iteration</h4>
                    <div class="value" id="currentIteration">0</div>
                </div>
                <div class="metric-card">
                    <h4>Current Cost (Scaled)</h4>
                    <div class="value" id="trainingCost">0</div>
                </div>
                <div class="metric-card">
                    <h4>Scaled 'a'</h4>
                    <div class="value" id="currentAScaled">0</div>
                </div>
                <div class="metric-card">
                    <h4>Scaled 'b'</h4>
                    <div class="value" id="currentBScaled">0</div>
                </div>
                <div class="metric-card">
                    <h4>Scaled 'c'</h4>
                    <div class="value" id="currentCScaled">0</div>
                </div>
                <div class="metric-card">
                    <h4>‚àÇJ/‚àÇa (Scaled)</h4>
                    <div class="value" id="aGradient">0</div>
                </div>
                <div class="metric-card">
                    <h4>‚àÇJ/‚àÇb (Scaled)</h4>
                    <div class="value" id="bGradient">0</div>
                </div>
                <div class="metric-card">
                    <h4>‚àÇJ/‚àÇc (Scaled)</h4>
                    <div class="value" id="cGradient">0</div>
                </div>
            </div>
        </div>

        <div class="final-solution">
            <h3>üéâ Training Complete!</h3>
            <p>Gradient Descent has found the optimal parameters for the quadratic model.</p>
            <div class="formula" style="background: rgba(255,255,255,0.2); margin: 20px 0;">
                Optimal Scaled Parameters:<br>
                A = <span id="finalAScaled">A</span><br>
                B = <span id="finalBScaled">B</span><br>
                C = <span id="finalCScaled">C</span>
            </div>
            <p>These parameters define the U-shaped curve that best fits our Average Cost data.</p>
        </div>
    </div>

    <script>
        // Original Training data: Quantity vs. Average Cost
        const originalData = [
            {x: 10, y: 25.0},
            {x: 20, y: 18.0},
            {x: 30, y: 13.0},
            {x: 40, y: 10.0},
            {x: 50, y: 9.0},
            {x: 60, y: 9.5},
            {x: 70, y: 11.0},
            {x: 80, y: 14.0},
            {x: 90, y: 18.0},
            {x: 100, y: 23.0}
        ];

        // --- Data Normalization Parameters ---
        const xValues = originalData.map(d => d.x);
        const yValues = originalData.map(d => d.y);

        const minX = Math.min(...xValues);
        const maxX = Math.max(...xValues);
        const minY = Math.min(...yValues);
        const maxY = Math.max(...yValues);

        // Scaled data points
        const data_scaled = originalData.map(d => ({
            x: (d.x - minX) / (maxX - minX),
            y: (d.y - minY) / (maxY - minY)
        }));

        // Helper function to normalize a single X value from original scale to 0-1
        function normalizeX(originalX) {
            return (originalX - minX) / (maxX - minX);
        }

        // Helper function to denormalize a single Y value from 0-1 to original scale
        function denormalizeY(scaledY) {
            return scaledY * (maxY - minY) + minY;
        }

        // --- Global variables for training (these will be in the scaled space) ---
        let currentA; // Scaled 'a' parameter for x^2 term
        let currentB; // Scaled 'b' parameter for x term
        let currentC; // Scaled 'c' parameter (bias/intercept)
        let iteration;
        let trainingInterval = null;

        // Canvas elements
        let dataCanvasElement, trainingCanvasElement;

        // Initialize canvases and controls on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            dataCanvasElement = document.getElementById('dataCanvas');
            trainingCanvasElement = document.getElementById('trainingCanvas');

            // Initial drawing for data canvas (no regression curve initially)
            drawChart(dataCanvasElement, 0, 0, 0, false); 
            
            // Set up oninput events for training simulation sliders
            document.getElementById('learningRateSlider').oninput = () => {
                document.getElementById('learningRateValue').textContent = parseFloat(document.getElementById('learningRateSlider').value).toFixed(2);
            };
            document.getElementById('maxIterationsSlider').oninput = () => {
                document.getElementById('maxIterationsValue').textContent = document.getElementById('maxIterationsSlider').value;
            };
            document.getElementById('convergenceThresholdSlider').oninput = () => {
                document.getElementById('convergenceThresholdValue').textContent = parseFloat(document.getElementById('convergenceThresholdSlider').value).toFixed(8);
            };

            // Set initial values and draw for training simulation
            resetTraining(); 
        });

        // Calculate prediction for given A, B, C (on scaled data)
        function predict(A, B, C, x_scaled) {
            return A * x_scaled * x_scaled + B * x_scaled + C;
        }

        // Calculate cost function (MSE) (on scaled data)
        function calculateCost(A_scaled, B_scaled, C_scaled) {
            let totalError = 0;
            for (let i = 0; i < data_scaled.length; i++) {
                const prediction_scaled = predict(A_scaled, B_scaled, C_scaled, data_scaled[i].x);
                const error_scaled = data_scaled[i].y - prediction_scaled; // y_actual_scaled - y_predicted_scaled
                totalError += error_scaled * error_scaled;
            }
            return totalError / (2 * data_scaled.length);
        }

        // Calculate gradients (on scaled data)
        function calculateGradients(A_scaled, B_scaled, C_scaled) {
            let gradientA_scaled = 0;
            let gradientB_scaled = 0;
            let gradientC_scaled = 0;
            
            for (let i = 0; i < data_scaled.length; i++) {
                const prediction_scaled = predict(A_scaled, B_scaled, C_scaled, data_scaled[i].x);
                const error_scaled = data_scaled[i].y - prediction_scaled; // (y_actual - y_predicted)

                // Note: Gradients are derived assuming cost = (1/2n) * SUM (y_actual - y_predicted)^2
                // To match the update rule: param = param - alpha * gradient,
                // we use (y_predicted - y_actual) as the error term in the sum.
                // Or, equivalently, negate the sum of (y_actual - y_predicted).
                gradientA_scaled += error_scaled * data_scaled[i].x * data_scaled[i].x;
                gradientB_scaled += error_scaled * data_scaled[i].x;
                gradientC_scaled += error_scaled;
            }
            
            gradientA_scaled /= -data_scaled.length; 
            gradientB_scaled /= -data_scaled.length; 
            gradientC_scaled /= -data_scaled.length; 
            
            return { gradientA: gradientA_scaled, gradientB: gradientB_scaled, gradientC: gradientC_scaled };
        }

        // Draw data points and regression curve
        function drawChart(canvas, A_val, B_val, C_val, showCurve = true) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Define fixed viewport for charts
            const displayMinX = 0; // Quantity starts from 10, but 0 is a nice start for chart
            const displayMaxX = 110; // Max Quantity 100
            const displayMinY = 5;   // Min Cost 9.0
            const displayMaxY = 30;  // Max Cost 25.0
            
            const scaleX = (width - 100) / (displayMaxX - displayMinX);
            const scaleY = (height - 100) / (displayMaxY - displayMinY);
            
            function canvasX(x) {
                return 50 + (x - displayMinX) * scaleX;
            }
            
            function canvasY(y) {
                return height - 50 - (y - displayMinY) * scaleY;
            }
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, height - 50); // X-axis
            ctx.lineTo(width - 50, height - 50);
            ctx.moveTo(50, 50);         // Y-axis
            ctx.lineTo(50, height - 50);
            ctx.stroke();
            
            // Set font for labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Draw x-axis grid and labels
            ctx.strokeStyle = '#f0f0f0';
            for (let x_val = 0; x_val <= 110; x_val += 10) { 
                const xCanvasPos = canvasX(x_val);
                if (xCanvasPos < 50 || xCanvasPos > width - 50) continue; 
                ctx.beginPath();
                ctx.moveTo(xCanvasPos, 50);
                ctx.lineTo(xCanvasPos, height - 50);
                ctx.stroke();
                ctx.fillText(x_val.toLocaleString(), xCanvasPos, height - 30); 
            }
            
            // Draw y-axis grid and labels
            for (let y_val = 5; y_val <= 30; y_val += 5) { 
                const yCanvasPos = canvasY(y_val);
                if (yCanvasPos < 50 || yCanvasPos > height - 50) continue; 
                ctx.beginPath();
                ctx.moveTo(50, yCanvasPos);
                ctx.lineTo(width - 50, yCanvasPos);
                ctx.stroke();
                ctx.textAlign = 'right'; 
                ctx.fillText(y_val.toFixed(1), 40, yCanvasPos + 5); 
                ctx.textAlign = 'center'; 
            }
            
            // Draw quadratic regression curve
            if (showCurve) {
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                // Draw curve by iterating through a range of x values
                for (let x = displayMinX; x <= displayMaxX; x += 0.5) { // Use smaller steps for smoother curve
                    const x_norm = normalizeX(x);
                    const y_pred_norm = predict(A_val, B_val, C_val, x_norm);
                    const y_pred = denormalizeY(y_pred_norm);

                    const currentX = canvasX(x);
                    const currentY = canvasY(y_pred);

                    if (x === displayMinX) {
                        ctx.moveTo(currentX, currentY);
                    } else {
                        ctx.lineTo(currentX, currentY);
                    }
                }
                ctx.stroke();
            }
            
            // Draw original data points
            originalData.forEach((point) => {
                const x = canvasX(point.x);
                const y = canvasY(point.y);
                
                // Actual data point
                ctx.fillStyle = '#4ecdc4';
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Add main axis labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Quantity Produced (x)', width / 2, height - 10);
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Average Cost (y)', 0, 0);
            ctx.restore();
        }

        // Single step of gradient descent
        function singleStep() {
            iteration++;
            const learningRate = parseFloat(document.getElementById('learningRateSlider').value);
            const maxIterations = parseInt(document.getElementById('maxIterationsSlider').value);
            const convergenceThreshold = parseFloat(document.getElementById('convergenceThresholdSlider').value);

            const prevCost = calculateCost(currentA, currentB, currentC);

            const { gradientA, gradientB, gradientC } = calculateGradients(currentA, currentB, currentC);
            
            // Update parameters in the scaled space
            currentA -= learningRate * gradientA;
            currentB -= learningRate * gradientB;
            currentC -= learningRate * gradientC;

            const currentCost = calculateCost(currentA, currentB, currentC);

            // Update UI metrics
            document.getElementById('currentIteration').textContent = iteration;
            document.getElementById('trainingCost').textContent = currentCost.toFixed(8); 
            document.getElementById('currentAScaled').textContent = currentA.toFixed(6);
            document.getElementById('currentBScaled').textContent = currentB.toFixed(6);
            document.getElementById('currentCScaled').textContent = currentC.toFixed(6);
            document.getElementById('aGradient').textContent = gradientA.toFixed(8);
            document.getElementById('bGradient').textContent = gradientB.toFixed(8);
            document.getElementById('cGradient').textContent = gradientC.toFixed(8);

            // Update iteration details box
            const iterationDetails = document.getElementById('iterationDetails');
            iterationDetails.innerHTML = `
                <div class="calculation-step"><span>New Scaled 'a' = ${currentA.toFixed(6)}</span></div>
                <div class="calculation-step"><span>New Scaled 'b' = ${currentB.toFixed(6)}</span></div>
                <div class="calculation-step"><span>New Scaled 'c' = ${currentC.toFixed(6)}</span></div>
                <div class="calculation-step"><span>Scaled Cost J(a,b,c) = ${currentCost.toFixed(8)}</span></div>
            `;
            document.getElementById('iterationNumber').textContent = iteration;
            document.getElementById('iterationInfo').style.display = 'block';

            // Draw on training canvas
            drawChart(trainingCanvasElement, currentA, currentB, currentC, true);

            // Check for convergence or max iterations
            if (iteration >= maxIterations || Math.abs(prevCost - currentCost) < convergenceThreshold) {
                stopTraining();
                // Display final scaled parameters
                document.getElementById('finalAScaled').textContent = currentA.toFixed(6);
                document.getElementById('finalBScaled').textContent = currentB.toFixed(6);
                document.getElementById('finalCScaled').textContent = currentC.toFixed(6);
                
                if (Math.abs(prevCost - currentCost) < convergenceThreshold) {
                    alert(`Training stopped due to convergence at iteration ${iteration}! Cost change (${Math.abs(prevCost - currentCost).toFixed(8)}) was less than threshold (${convergenceThreshold.toFixed(8)}).`);
                } else {
                    alert(`Training completed after ${iteration} iterations (max iterations reached).`);
                }
            }
        }

        // Start continuous training
        function startTraining() {
            stopTraining(); // Clear any existing interval
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stepBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            trainingInterval = setInterval(singleStep, 50); // Run every 50ms for smoother animation
        }

        // Stop continuous training
        function stopTraining() {
            clearInterval(trainingInterval);
            trainingInterval = null;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        // Reset training
        function resetTraining() {
            stopTraining();
            // Get initial scaled values from sliders
            currentA = parseFloat(document.getElementById('initAScaledSlider').value);
            currentB = parseFloat(document.getElementById('initBScaledSlider').value);
            currentC = parseFloat(document.getElementById('initCScaledSlider').value);
            
            iteration = 0;

            // Reset UI elements
            document.getElementById('currentIteration').textContent = 0;
            document.getElementById('trainingCost').textContent = calculateCost(currentA, currentB, currentC).toFixed(8);
            document.getElementById('currentAScaled').textContent = currentA.toFixed(6);
            document.getElementById('currentBScaled').textContent = currentB.toFixed(6);
            document.getElementById('currentCScaled').textContent = currentC.toFixed(6);
            document.getElementById('aGradient').textContent = "0.00000000";
            document.getElementById('bGradient').textContent = "0.00000000";
            document.getElementById('cGradient').textContent = "0.00000000";
            document.getElementById('iterationInfo').style.display = 'none';
            
            document.getElementById('finalAScaled').textContent = "A";
            document.getElementById('finalBScaled').textContent = "B";
            document.getElementById('finalCScaled').textContent = "C";

            // Redraw training canvas with initial scaled values
            drawChart(trainingCanvasElement, currentA, currentB, currentC, true);
        }
    </script>
</body>
</html>