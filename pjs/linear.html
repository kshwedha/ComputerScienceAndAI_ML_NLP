<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Descent: Complete Step-by-Step Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
            padding: 40px 0;
        }

        .header h1 {
            font-size: 3.5rem;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.3rem;
            opacity: 0.9;
            margin-bottom: 10px;
        }

        .step {
            background: white;
            border-radius: 20px;
            padding: 35px;
            margin-bottom: 40px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
            transition: transform 0.3s ease;
        }

        .step:hover {
            transform: translateY(-3px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
        }

        .step::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57);
        }

        .step-number {
            position: absolute;
            top: -20px;
            right: 30px;
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.4rem;
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
            z-index: 10;
        }

        .step h2 {
            color: #2c3e50;
            margin-bottom: 25px;
            font-size: 2.2rem;
            font-weight: 700;
        }

        .step h3 {
            color: #34495e;
            margin: 25px 0 15px 0;
            font-size: 1.5rem;
            border-left: 4px solid #4ecdc4;
            padding-left: 15px;
        }

        .math-section {
            background: linear-gradient(135deg, #f8f9ff, #e8f4fd);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border-left: 6px solid #4ecdc4;
            position: relative;
        }

        .math-section::before {
            content: "üìê";
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 1.5rem;
        }

        .formula {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 20px;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            margin: 20px 0;
            text-align: center;
            font-size: 1.3rem;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        .formula::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #4ecdc4, #45b7d1);
        }

        .calculation-box {
            background: linear-gradient(135deg, #fff5f5, #fed7d7);
            border: 2px solid #fc8181;
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
        }

        .calculation-step {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px dashed #ccc;
        }

        .calculation-step:last-child {
            border-bottom: none;
            font-weight: bold;
            background: rgba(76, 175, 80, 0.1);
            margin: 10px -10px -10px -10px;
            padding: 15px 20px;
            border-radius: 8px;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .data-table th {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
            padding: 15px;
            text-align: center;
            font-weight: 600;
        }

        .data-table td {
            padding: 12px 15px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        .data-table tr:hover {
            background: #f8f9fa;
        }

        .iteration-demo {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            border: 2px solid #28a745;
        }

        .iteration-header {
            background: #28a745;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            display: inline-block;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .interactive-controls {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin: 25px 0;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .control-group {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .control-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #fff;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255,255,255,0.3);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            position: relative;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin: 25px 0;
        }

        .metric-card {
            background: linear-gradient(135deg, #a8edea, #fed6e3);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            transition: transform 0.2s ease;
        }

        .metric-card:hover {
            transform: scale(1.05);
        }

        .metric-card h4 {
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .metric-card .value {
            font-size: 2rem;
            font-weight: bold;
            color: #e74c3c;
        }

        .explanation-box {
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border-left: 5px solid #e17055;
        }

        .explanation-box h4 {
            color: #2d3436;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .gradient-visualization {
            display: flex;
            align-items: center;
            justify-content: space-around;
            background: linear-gradient(135deg, #fdcb6e, #e17055);
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            color: white;
        }

        .gradient-arrow {
            font-size: 3rem;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        .algorithm-box {
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
        }

        .algorithm-step {
            background: rgba(255,255,255,0.1);
            margin: 10px 0;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #fff;
        }

        button {
            background: linear-gradient(135deg, #00b894, #00cec9);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .final-solution {
            background: linear-gradient(135deg, #00b894, #00cec9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            margin-top: 40px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.2);
        }

        .final-solution h3 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: white;
        }

        @media (max-width: 768px) {
            .header h1 { font-size: 2.5rem; }
            .step { padding: 20px; }
            .controls-grid { grid-template-columns: 1fr; }
            .metrics-grid { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè† Housing Price Prediction</h1>
            <p>Complete Step-by-Step Mathematical Guide</p>
            <p><em>üéØ Linear Regression</em></p>
        </div>

        <div class="step">
            <div class="step-number">1</div>
            <h2>üè† Problem Setup & Data</h2>
            <p>We want to predict house prices based on size using linear regression. Our model equation is:</p>
            
            <div class="formula">
                ≈∑ = mx + b
            </div>
            
            <p>Where:</p>
            <ul style="margin: 15px 0; padding-left: 30px;">
                <li><strong>≈∑</strong> = predicted price</li>
                <li><strong>m</strong> = slope (weight) - price per sq ft</li>
                <li><strong>x</strong> = house size in sq ft</li>
                <li><strong>b</strong> = y-intercept (bias) - base price</li>
            </ul>
            
            <h3>üìä Training Dataset</h3>
            <table class="data-table">
                <thead>
                    <tr>
                        <th>House #</th>
                        <th>Size (x) sq ft</th>
                        <th>Actual Price (y) $</th>
                    </tr>
                </thead>
                <tbody id="dataTableBody">
                    <tr><td>1</td><td>1000</td><td>200,000</td></tr>
                    <tr><td>2</td><td>1200</td><td>220,000</td></tr>
                    <tr><td>3</td><td>1500</td><td>280,000</td></tr>
                    <tr><td>4</td><td>1800</td><td>320,000</td></tr>
                    <tr><td>5</td><td>2000</td><td>380,000</td></tr>
                </tbody>
            </table>
            
            <div class="chart-container">
                <canvas id="dataCanvas" width="600" height="300"></canvas>
            </div>
        </div>

        <div class="step">
            <div class="step-number">2</div>
            <h2>üìè Cost Function (Mean Squared Error)</h2>
            
            <p>We need to measure how wrong our predictions are. We use the Mean Squared Error (MSE) cost function:</p>
            
            <div class="formula">
                J(m,b) = (1/2n) √ó Œ£(y·µ¢ - ≈∑·µ¢)¬≤
            </div>
            
            <div class="math-section">
                <h4>üîç Breaking Down the Cost Function</h4>
                <p><strong>Step 1:</strong> Calculate prediction for each house: ≈∑·µ¢ = m √ó x·µ¢ + b</p>
                <p><strong>Step 2:</strong> Find the error: (y·µ¢ - ≈∑·µ¢)</p>
                <p><strong>Step 3:</strong> Square the error: (y·µ¢ - ≈∑·µ¢)¬≤</p>
                <p><strong>Step 4:</strong> Sum all squared errors and average: (1/2n) √ó Œ£(y·µ¢ - ≈∑·µ¢)¬≤</p>
                <p><em>Note: The 1/2 factor simplifies the derivative calculation</em></p>
            </div>

            <div class="interactive-controls">
                <h4>üéÆ Interactive Cost Function Visualization</h4>
                <div class="controls-grid">
                    <div class="control-group">
                        <label>Slope (m): <span id="slopeValue">150</span></label>
                        <input type="range" id="slopeSlider" min="50" max="300" value="150" oninput="updateCostVisualization()">
                    </div>
                    <div class="control-group">
                        <label>Intercept (b): <span id="interceptValue">50,000</span></label>
                        <input type="range" id="interceptSlider" min="0" max="100000" value="50000" oninput="updateCostVisualization()">
                    </div>
                </div>
                
                <div class="chart-container">
                    <canvas id="costCanvas" width="600" height="300"></canvas>
                </div>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h4>Current Cost J(m,b)</h4>
                        <div class="value" id="currentCost">0</div>
                    </div>
                    <div class="metric-card">
                        <h4>RMSE</h4>
                        <div class="value" id="rmseValue">0</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="step">
            <div class="step-number">3</div>
            <h2>‚àá Partial Derivatives (Gradients)</h2>
            
            <p>To minimize the cost function, we need to find the partial derivatives with respect to both parameters:</p>
            
            <div class="math-section">
                <h4>üìê Derivative with respect to slope (m):</h4>
                <div class="formula">
                    ‚àÇJ/‚àÇm = (1/n) √ó Œ£(≈∑·µ¢ - y·µ¢) √ó x·µ¢
                </div>
                
                <h4>üìê Derivative with respect to intercept (b):</h4>
                <div class="formula">
                    ‚àÇJ/‚àÇb = (1/n) √ó Œ£(≈∑·µ¢ - y·µ¢)
                </div>
            </div>
            
            <div class="explanation-box">
                <h4>üß† Intuitive Understanding</h4>
                <p><strong>Positive Gradient:</strong> Cost increases as parameter increases ‚Üí Move parameter DOWN</p>
                <p><strong>Negative Gradient:</strong> Cost decreases as parameter increases ‚Üí Move parameter UP</p>
                <p>The gradient points in the direction of steepest ascent, so we move in the opposite direction!</p>
            </div>

            <div class="gradient-visualization">
                <div>
                    <h4>High Cost</h4>
                    <div style="font-size: 2rem;">üìà</div>
                </div>
                <div class="gradient-arrow">‚¨áÔ∏è</div>
                <div>
                    <h4>Gradient Descent</h4>
                    <div style="font-size: 2rem;">üéØ</div>
                </div>
                <div class="gradient-arrow">‚¨áÔ∏è</div>
                <div>
                    <h4>Low Cost</h4>
                    <div style="font-size: 2rem;">üìâ</div>
                </div>
            </div>
        </div>

        <div class="step">
            <div class="step-number">4</div>
            <h2>üìù Manual Calculation Example</h2>
            
            <p>Let's calculate one iteration step by step with initial values: m = 100, b = 50000</p>
            
            <div class="calculation-box">
                <h4>Step 1: Calculate Predictions</h4>
                <div class="calculation-step">
                    <span>≈∑‚ÇÅ = 100 √ó 1000 + 50000</span>
                    <span>= 150,000</span>
                </div>
                <div class="calculation-step">
                    <span>≈∑‚ÇÇ = 100 √ó 1200 + 50000</span>
                    <span>= 170,000</span>
                </div>
                <div class="calculation-step">
                    <span>≈∑‚ÇÉ = 100 √ó 1500 + 50000</span>
                    <span>= 200,000</span>
                </div>
                <div class="calculation-step">
                    <span>≈∑‚ÇÑ = 100 √ó 1800 + 50000</span>
                    <span>= 230,000</span>
                </div>
                <div class="calculation-step">
                    <span>≈∑‚ÇÖ = 100 √ó 2000 + 50000</span>
                    <span>= 250,000</span>
                </div>
            </div>

            <div class="calculation-box">
                <h4>Step 2: Calculate Errors</h4>
                <div class="calculation-step">
                    <span>e‚ÇÅ = 150,000 - 200,000</span>
                    <span>= -50,000</span>
                </div>
                <div class="calculation-step">
                    <span>e‚ÇÇ = 170,000 - 220,000</span>
                    <span>= -50,000</span>
                </div>
                <div class="calculation-step">
                    <span>e‚ÇÉ = 200,000 - 280,000</span>
                    <span>= -80,000</span>
                </div>
                <div class="calculation-step">
                    <span>e‚ÇÑ = 230,000 - 320,000</span>
                    <span>= -90,000</span>
                </div>
                <div class="calculation-step">
                    <span>e‚ÇÖ = 250,000 - 380,000</span>
                    <span>= -130,000</span>
                </div>
            </div>

            <div class="calculation-box">
                <h4>Step 3: Calculate Gradients</h4>
                <div class="calculation-step">
                    <span>‚àÇJ/‚àÇm = (1/5) √ó [(-50000√ó1000) + (-50000√ó1200) + (-80000√ó1500) + (-90000√ó1800) + (-130000√ó2000)]</span>
                </div>
                <div class="calculation-step">
                    <span>‚àÇJ/‚àÇm = (1/5) √ó [-50M - 60M - 120M - 162M - 260M]</span>
                    <span>= -130,400,000</span>
                </div>
                <div class="calculation-step">
                    <span>‚àÇJ/‚àÇb = (1/5) √ó [-50000 + -50000 + -80000 + -90000 + -130000]</span>
                    <span>= -80,000</span>
                </div>
            </div>
        </div>

        <div class="step">
            <div class="step-number">5</div>
            <h2>üöÄ Learning Rate & Parameter Updates</h2>
            
            <div class="algorithm-box">
                <h4>üîÑ Gradient Descent Algorithm</h4>
                <div class="algorithm-step">
                    <strong>Step 1:</strong> Initialize parameters m and b randomly
                </div>
                <div class="algorithm-step">
                    <strong>Step 2:</strong> Calculate cost J(m,b)
                </div>
                <div class="algorithm-step">
                    <strong>Step 3:</strong> Calculate gradients ‚àÇJ/‚àÇm and ‚àÇJ/‚àÇb
                </div>
                <div class="algorithm-step">
                    <strong>Step 4:</strong> Update parameters: m = m - Œ± √ó ‚àÇJ/‚àÇm, b = b - Œ± √ó ‚àÇJ/‚àÇb
                </div>
                <div class="algorithm-step">
                    <strong>Step 5:</strong> Repeat steps 2-4 until convergence
                </div>
            </div>
            
            <div class="formula">
                m<sub>new</sub> = m<sub>old</sub> - Œ± √ó ‚àÇJ/‚àÇm<br>
                b<sub>new</sub> = b<sub>old</sub> - Œ± √ó ‚àÇJ/‚àÇb
            </div>
            
            <div class="explanation-box">
                <h4>üéõÔ∏è Learning Rate (Œ±) Effects</h4>
                <p><strong>Too Small (Œ± ‚âà 0.00001):</strong> Very slow convergence, many iterations needed</p>
                <p><strong>Too Large (Œ± ‚âà 0.1):</strong> May overshoot minimum, oscillate or diverge</p>
                <p><strong>Just Right (Œ± ‚âà 0.001):</strong> Steady progress toward minimum</p>
            </div>

            <div class="calculation-box">
                <h4>Example Update (Œ± = 0.000001)</h4>
                <div class="calculation-step">
                    <span>m<sub>new</sub> = 100 - 0.000001 √ó (-130,400,000)</span>
                    <span>= 100 + 130.4 = 230.4</span>
                </div>
                <div class="calculation-step">
                    <span>b<sub>new</sub> = 50000 - 0.000001 √ó (-80,000)</span>
                    <span>= 50000 + 80 = 50,080</span>
                </div>
            </div>
        </div>

        <div class="step">
            <div class="step-number">6</div>
            <h2>üéÆ Interactive Training Simulation</h2>
            
            <div class="interactive-controls">
                <h4>üèÉ‚Äç‚ôÇÔ∏è Watch Gradient Descent in Action!</h4>
                
                <div class="controls-grid">
                    <div class="control-group">
                        <label>Learning Rate (Œ±): <span id="learningRateValue">0.5</span></label>
                        <input type="range" id="learningRateSlider" min="0.01" max="1.0" step="0.01" value="0.5" oninput="document.getElementById('learningRateValue').textContent = parseFloat(this.value).toFixed(2)">
                    </div>
                    <div class="control-group">
                        <label>Initial Slope (m): <span id="initSlopeValue">100</span></label>
                        <input type="range" id="initSlopeSlider" min="0" max="300" step="1" value="100" oninput="document.getElementById('initSlopeValue').textContent = this.value; resetTraining()">
                    </div>
                    <div class="control-group">
                        <label>Initial Intercept (b): <span id="initInterceptValue">50,000</span></label>
                        <input type="range" id="initInterceptSlider" min="-50000" max="150000" step="1000" value="50000" oninput="document.getElementById('initInterceptValue').textContent = parseInt(this.value).toLocaleString(); resetTraining()">
                    </div>
                    <div class="control-group">
                        <label>Max Iterations: <span id="maxIterationsValue">5000</span></label>
                        <input type="range" id="maxIterationsSlider" min="100" max="10000" step="100" value="5000" oninput="document.getElementById('maxIterationsValue').textContent = this.value">
                    </div>
                    <div class="control-group">
                        <label>Convergence Threshold: <span id="convergenceThresholdValue">0.000001</span></label>
                        <input type="range" id="convergenceThresholdSlider" min="0.0000001" max="0.001" step="0.0000001" value="0.000001" oninput="document.getElementById('convergenceThresholdValue').textContent = parseFloat(this.value).toFixed(7)">
                    </div>
                </div>
                
                <div style="text-align: center; margin: 20px 0;">
                    <button id="startBtn" onclick="startTraining()">üöÄ Start Training</button>
                    <button id="stopBtn" onclick="stopTraining()" disabled>‚è∏Ô∏è Stop Training</button>
                    <button id="stepBtn" onclick="singleStep()">‚û°Ô∏è Single Step</button>
                    <button id="resetBtn" onclick="resetTraining()">üîÑ Reset</button>
                </div>
            </div>

            <div class="iteration-demo" id="iterationInfo" style="display: none;">
                <div class="iteration-header">Iteration <span id="iterationNumber">1</span></div>
                <div class="calculation-box">
                    <div id="iterationDetails"></div>
                </div>
            </div>
            
            <div class="chart-container">
                <canvas id="trainingCanvas" width="600" height="300"></canvas>
            </div>
            
            <div class="metrics-grid">
                <div class="metric-card">
                    <h4>Iteration</h4>
                    <div class="value" id="currentIteration">0</div>
                </div>
                <div class="metric-card">
                    <h4>Current Cost (Scaled)</h4>
                    <div class="value" id="trainingCost">0</div>
                </div>
                <div class="metric-card">
                    <h4>Slope (m)</h4>
                    <div class="value" id="currentSlope">0</div>
                </div>
                <div class="metric-card">
                    <h4>Intercept (b)</h4>
                    <div class="value" id="currentIntercept">0</div>
                </div>
                <div class="metric-card">
                    <h4>‚àÇJ/‚àÇm (Scaled)</h4>
                    <div class="value" id="slopeGradient">0</div>
                </div>
                <div class="metric-card">
                    <h4>‚àÇJ/‚àÇb (Scaled)</h4>
                    <div class="value" id="interceptGradient">0</div>
                </div>
            </div>
        </div>

        <div class="final-solution">
            <h3>üéâ Congratulations!</h3>
            <p>You've successfully learned gradient descent from the ground up!</p>
            <div class="formula" style="background: rgba(255,255,255,0.2); margin: 20px 0;">
                Final Model: Price = <span id="finalSlope">m</span> √ó Size + <span id="finalIntercept">b</span>
            </div>
            <p>The optimal parameters found minimize the prediction error on our training data!</p>
        </div>
    </div>

    <script>
        // Original Training data
        const originalData = [
            {x: 1000, y: 200000},
            {x: 1200, y: 220000},
            {x: 1500, y: 280000},
            {x: 1800, y: 320000},
            {x: 2000, y: 380000}
        ];

        // --- Data Normalization ---
        const xValues = originalData.map(d => d.x);
        const yValues = originalData.map(d => d.y);

        const minX = Math.min(...xValues);
        const maxX = Math.max(...xValues);
        const minY = Math.min(...yValues);
        const maxY = Math.max(...yValues);

        // Scaled data points
        const data_scaled = originalData.map(d => ({
            x: (d.x - minX) / (maxX - minX),
            y: (d.y - minY) / (maxY - minY)
        }));

        // Helper function to normalize a single X value from original scale to 0-1
        function normalizeX(originalX) {
            return (originalX - minX) / (maxX - minX);
        }

        // Helper function to normalize a single Y value from original scale to 0-1
        function normalizeY(originalY) {
            return (originalY - minY) / (maxY - minY);
        }

        // Helper function to denormalize x
        function denormalizeX(scaledX) {
            return scaledX * (maxX - minX) + minX;
        }

        // Helper function to denormalize y
        function denormalizeY(scaledY) {
            return scaledY * (maxY - minY) + minY;
        }

        // Helper function to convert scaled slope/intercept back to original scale
        function getOriginalParameters(m_scaled, b_scaled) {
            const m_original = m_scaled * (maxY - minY) / (maxX - minX);
            const b_original = b_scaled * (maxY - minY) + minY - m_original * minX;
            return { m_original, b_original };
        }

        // Helper function to convert original slope/intercept to scaled parameters
        function getScaledParameters(m_original, b_original) {
            const m_scaled = m_original * (maxX - minX) / (maxY - minY);
            const b_scaled = (b_original - minY + m_original * minX) / (maxY - minY);
            return { m_scaled, b_scaled };
        }
        // --- End Data Normalization ---


        // Global variables for training (these will be in the scaled space)
        let currentM; // This will hold the scaled slope
        let currentB; // This will hold the scaled intercept
        let iteration;
        let trainingInterval = null;
        let costHistory = [];

        // Canvas elements (not contexts)
        let dataCanvasElement, costCanvasElement, trainingCanvasElement;

        // Initialize canvases and controls on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            dataCanvasElement = document.getElementById('dataCanvas');
            costCanvasElement = document.getElementById('costCanvas');
            trainingCanvasElement = document.getElementById('trainingCanvas');

            // Initial drawing for data canvas (no regression line initially, draws original data)
            drawChart(dataCanvasElement, 0, 0, false); 
            
            // Set up oninput events for cost visualization sliders (THIS IS THE KEY FIX FOR LIVE UPDATES)
            document.getElementById('slopeSlider').oninput = updateCostVisualization;
            document.getElementById('interceptSlider').oninput = updateCostVisualization;
            
            // Initial drawing for cost visualization
            updateCostVisualization();

            // Set initial values for training simulation
            // This function is also called by the initSlope/Intercept sliders' oninput events
            resetTraining(); 
        });

        // Calculate predictions for given m and b (on scaled data)
        function predict(m, b, x_scaled) {
            return m * x_scaled + b;
        }

        // Calculate cost function (MSE) (on scaled data)
        function calculateCost(m_scaled, b_scaled) {
            let totalError = 0;
            for (let i = 0; i < data_scaled.length; i++) {
                const prediction_scaled = predict(m_scaled, b_scaled, data_scaled[i].x);
                const error_scaled = data_scaled[i].y - prediction_scaled; // y_actual_scaled - y_predicted_scaled
                totalError += error_scaled * error_scaled;
            }
            return totalError / (2 * data_scaled.length);
        }

        // Calculate gradients (on scaled data)
        function calculateGradients(m_scaled, b_scaled) {
            let gradientM_scaled = 0;
            let gradientB_scaled = 0;
            
            for (let i = 0; i < data_scaled.length; i++) {
                const prediction_scaled = predict(m_scaled, b_scaled, data_scaled[i].x);
                // The error here is (y_actual_scaled - y_predicted_scaled)
                const error_scaled = data_scaled[i].y - prediction_scaled; 

                // Note: The gradient formulas you have in the HTML are (y_predicted - y_actual)
                // If error = (y_actual - y_predicted), then we multiply by -1 for the gradient direction.
                // Your current code effectively uses (y_actual - y_predicted) and then divides by -n
                // making it equivalent to (1/n) * SUM (y_predicted - y_actual) * x
                gradientM_scaled += error_scaled * data_scaled[i].x;
                gradientB_scaled += error_scaled;
            }
            
            // Corrected sign for gradient descent: we want to move opposite to the gradient.
            // If error is (y_actual - y_predicted), then gradient needs to be (y_predicted - y_actual)
            // So, negate the sum for gradient descent update m = m - alpha * grad
            gradientM_scaled /= -data_scaled.length; 
            gradientB_scaled /= -data_scaled.length; 
            
            return { gradientM: gradientM_scaled, gradientB: gradientB_scaled };
        }

        // Draw data points and regression line
        // This function now handles drawing original data, but can accept scaled m, b for line drawing
        function drawChart(canvas, m_val, b_val, showPredictions = true, isScaled = false) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Set up coordinate system with desired fixed min/max for display
            // Based on user request
            const displayMinX = 800;
            const displayMaxX = 2200; // Extend beyond max data X (2000) for padding
            const displayMinY = 150000;
            const displayMaxY = 400000; // Extend beyond max data Y (380000) for padding
            
            const scaleX = (width - 100) / (displayMaxX - displayMinX);
            const scaleY = (height - 100) / (displayMaxY - displayMinY);
            
            function canvasX(x) {
                return 50 + (x - displayMinX) * scaleX;
            }
            
            function canvasY(y) {
                return height - 50 - (y - displayMinY) * scaleY;
            }
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, height - 50); // X-axis
            ctx.lineTo(width - 50, height - 50);
            ctx.moveTo(50, 50);         // Y-axis
            ctx.lineTo(50, height - 50);
            ctx.stroke();
            
            // Set font for labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Draw x-axis grid and labels
            ctx.strokeStyle = '#f0f0f0';
            for (let x_val = displayMinX; x_val <= displayMaxX; x_val += 200) { // Loop adjusted for new range
                const xCanvasPos = canvasX(x_val);
                if (xCanvasPos < 50 || xCanvasPos > width - 50) continue; // Only draw inside plot area
                ctx.beginPath();
                ctx.moveTo(xCanvasPos, 50);
                ctx.lineTo(xCanvasPos, height - 50);
                ctx.stroke();
                ctx.fillText(x_val.toLocaleString(), xCanvasPos, height - 30); // X labels
            }
            
            // Draw y-axis grid and labels
            for (let y_val = displayMinY; y_val <= displayMaxY; y_val += 50000) { // Loop adjusted for new range
                const yCanvasPos = canvasY(y_val);
                if (yCanvasPos < 50 || yCanvasPos > height - 50) continue; // Only draw inside plot area
                ctx.beginPath();
                ctx.moveTo(50, yCanvasPos);
                ctx.lineTo(width - 50, yCanvasPos);
                ctx.stroke();
                ctx.textAlign = 'right'; // Align Y labels to the right
                ctx.fillText(y_val.toLocaleString(), 40, yCanvasPos + 5); // Y labels
                ctx.textAlign = 'center'; // Reset for next loop/text
            }
            
            // Draw regression line (uses original m and b or converted scaled m,b)
            if (showPredictions) {
                let m_for_plot, b_for_plot;
                if (isScaled) {
                    // Convert scaled m, b to original m, b for plotting
                    const originalParams = getOriginalParameters(m_val, b_val);
                    m_for_plot = originalParams.m_original;
                    b_for_plot = originalParams.b_original;
                } else {
                    // Use m_val, b_val directly if they are already in original scale
                    m_for_plot = m_val;
                    b_for_plot = b_val; 
                }

                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                const y1 = m_for_plot * displayMinX + b_for_plot;
                const y2 = m_for_plot * displayMaxX + b_for_plot;
                ctx.moveTo(canvasX(displayMinX), canvasY(y1));
                ctx.lineTo(canvasX(displayMaxX), canvasY(y2));
                ctx.stroke();
            }
            
            // Draw original data points
            originalData.forEach((point) => {
                const x = canvasX(point.x);
                const y = canvasY(point.y);
                
                // Actual data point
                ctx.fillStyle = '#4ecdc4';
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // Prediction point (if showing predictions)
                if (showPredictions) {
                    let predY;
                    if (isScaled) {
                        // Predict with scaled parameters, then denormalize for plotting
                        const scaledPred = predict(m_val, b_val, normalizeX(point.x));
                        predY = denormalizeY(scaledPred);
                    } else {
                        // Predict directly with original parameters
                        predY = m_val * point.x + b_val;
                    }
                    
                    const predYCanvas = canvasY(predY);
                    
                    ctx.fillStyle = '#ff6b6b';
                    ctx.beginPath();
                    ctx.arc(x, predYCanvas, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Error line
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, predYCanvas);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
            
            // Add main axis labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial'; // Slightly larger font for axis titles
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Size (sq ft)', width / 2, height - 10);
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Price ($)', 0, 0);
            ctx.restore();
        }

        // Update cost visualization for Step 2 (uses original m and b values from sliders)
        function updateCostVisualization() {
            const m = parseFloat(document.getElementById('slopeSlider').value);
            const b = parseFloat(document.getElementById('interceptSlider').value);
            
            document.getElementById('slopeValue').textContent = m;
            document.getElementById('interceptValue').textContent = b.toLocaleString();
            
            // Calculate cost using original (unscaled) m and b
            let tempTotalError = 0;
            for(let i=0; i < originalData.length; i++) {
                const prediction = m * originalData[i].x + b;
                const error = originalData[i].y - prediction;
                tempTotalError += error * error;
            }
            const cost = tempTotalError / (2 * originalData.length);
            const rmse = Math.sqrt(2 * cost);
            
            document.getElementById('currentCost').textContent = cost.toLocaleString('en-US', {maximumFractionDigits: 0});
            document.getElementById('rmseValue').textContent = rmse.toLocaleString('en-US', {maximumFractionDigits: 0});
            
            // Draw chart using original m and b
            drawChart(costCanvasElement, m, b, true, false); 
        }

        // Single step of gradient descent for Step 6 (operates on scaled data)
        function singleStep() {
            iteration++;
            const learningRate = parseFloat(document.getElementById('learningRateSlider').value);
            const maxIterations = parseInt(document.getElementById('maxIterationsSlider').value);
            const convergenceThreshold = parseFloat(document.getElementById('convergenceThresholdSlider').value);

            const prevCost = calculateCost(currentM, currentB); // Store current cost BEFORE update

            const { gradientM, gradientB } = calculateGradients(currentM, currentB);
            
            // Update parameters in the scaled space
            currentM -= learningRate * gradientM;
            currentB -= learningRate * gradientB;

            const currentCost = calculateCost(currentM, currentB);
            costHistory.push(currentCost);

            // Log values for debugging the convergence (see browser console)
            console.log(`Iteration: ${iteration}, Prev Cost: ${prevCost.toFixed(8)}, Current Cost: ${currentCost.toFixed(8)}, Diff: ${Math.abs(prevCost - currentCost).toFixed(8)}, Threshold: ${convergenceThreshold.toFixed(8)}`);


            // Denormalize current M and B for display purposes
            const { m_original, b_original } = getOriginalParameters(currentM, currentB);

            // Update UI metrics
            document.getElementById('currentIteration').textContent = iteration;
            document.getElementById('trainingCost').textContent = currentCost.toFixed(6); // Display scaled cost
            // Display denormalized M and B for user understanding
            document.getElementById('currentSlope').textContent = m_original.toFixed(2);
            document.getElementById('currentIntercept').textContent = b_original.toFixed(0);
            document.getElementById('slopeGradient').textContent = gradientM.toFixed(4);
            document.getElementById('interceptGradient').textContent = gradientB.toFixed(4);

            // Update iteration details box
            const iterationDetails = document.getElementById('iterationDetails');
            iterationDetails.innerHTML = `
                <div class="calculation-step"><span>New Scaled Slope (m) = ${currentM.toFixed(4)} (denormalized: ${m_original.toFixed(2)})</span></div>
                <div class="calculation-step"><span>New Scaled Intercept (b) = ${currentB.toFixed(4)} (denormalized: ${b_original.toFixed(0)})</span></div>
                <div class="calculation-step"><span>Scaled Cost J(m,b) = ${currentCost.toFixed(6)}</span></div>
            `;
            document.getElementById('iterationNumber').textContent = iteration;
            document.getElementById('iterationInfo').style.display = 'block';

            // Draw on training canvas (pass scaled M and B, indicate they are scaled)
            drawChart(trainingCanvasElement, currentM, currentB, true, true);

            // Check for convergence or max iterations
            if (iteration >= maxIterations || Math.abs(prevCost - currentCost) < convergenceThreshold) {
                stopTraining();
                // Display final parameters denormalized to original scale
                const { m_original, b_original } = getOriginalParameters(currentM, currentB);
                document.getElementById('finalSlope').textContent = m_original.toFixed(2);
                document.getElementById('finalIntercept').textContent = b_original.toFixed(0);
                
                if (Math.abs(prevCost - currentCost) < convergenceThreshold) {
                    alert(`Training stopped due to convergence at iteration ${iteration}! Cost change (${Math.abs(prevCost - currentCost).toFixed(8)}) was less than threshold (${convergenceThreshold.toFixed(7)}).`);
                } else {
                    alert(`Training completed after ${iteration} iterations (max iterations reached).`);
                }
            }
        }

        // Start continuous training
        function startTraining() {
            stopTraining(); // Clear any existing interval
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stepBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            // The speed of updates can be adjusted here
            trainingInterval = setInterval(singleStep, 50); // Run every 50ms for smoother animation
        }

        // Stop continuous training
        function stopTraining() {
            clearInterval(trainingInterval);
            trainingInterval = null;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        // Reset training
        function resetTraining() {
            stopTraining();
            // Get original initial values from sliders
            const initialM_original = parseFloat(document.getElementById('initSlopeSlider').value);
            const initialB_original = parseFloat(document.getElementById('initInterceptSlider').value);

            // Convert original initial values to scaled space for training
            const { m_scaled, b_scaled } = getScaledParameters(initialM_original, initialB_original);
            currentM = m_scaled;
            currentB = b_scaled;
            
            iteration = 0;
            costHistory = [];

            // Reset UI elements
            document.getElementById('currentIteration').textContent = 0;
            document.getElementById('trainingCost').textContent = calculateCost(currentM, currentB).toFixed(6);
            // Display initial m and b in original values
            document.getElementById('currentSlope').textContent = initialM_original.toFixed(2);
            document.getElementById('currentIntercept').textContent = initialB_original.toFixed(0);
            document.getElementById('slopeGradient').textContent = "0.00";
            document.getElementById('interceptGradient').textContent = "0.00";
            document.getElementById('iterationInfo').style.display = 'none';
            
            document.getElementById('finalSlope').textContent = "m";
            document.getElementById('finalIntercept').textContent = "b";

            // Redraw training canvas with initial scaled values, but show original m and b
            drawChart(trainingCanvasElement, currentM, currentB, true, true);
        }
    </script>
</body>
</html>